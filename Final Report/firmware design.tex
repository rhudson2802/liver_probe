\section{Firmware Design}
%Config bits
%TRIS/ANSEL bits

\subsection{Measurements Algorithm}


\subsection{Communications Algorithm}

\subsection{Wireless Charging Algorithm}
The wireless charger requires a PWM signal with frequency $f=\SI{100}{\kilo\hertz}$ and duty cycle $D=0.5$. The PIC18F2550 has a built-in Capture/Compare/PWM (CCP) module \cite{pic18f2550}. This allows the PWM signal to be generated in hardware, rather than having to worry about precisely timing the software. A software implementation would have been difficult, as the PIC must do many other tasks as well as the PWM signal generation (such as listening for any incoming messages on the receiver), which would result in a variable delay time before the PWM could next be toggled. This is clearly undesirable, as it would not produce the desired constant frequency and duty ratio signal. The CCP pin could be set up as PWM at the beginning of the program and would continue to generate the signal regardless of what the rest of the program was doing.\\

PICBASIC contains a built-in command to access the CCP pins, HPWM (hardware PWM). This allows PWM to be set up simply by specifying the output pin, frequency and duty cycle \cite{picbasic pro}. However, because the free version of MicroCode Studio does not support the long data type, the highest frequency it can deliver is \SI{32.767}{\kilo\hertz}. The wireless charger was designed to run at \SI{100}{\kilo\hertz}, so the PWM signal needed to be faster than HPWM would allow. Therefore, a series of register writes were programmed to set up the CCP pin. The hardware was designed to use CCP module 2 on pin 24, which was multiplexed to PORTB.3. CCP2 could be multiplexed to either PORTC.1 (the default) or PORTB.3. Therefore, the appropriate CONFIG bit was set. In PICBASIC, this was \verb|CONFIG CCP2MX = OFF|.\\

The PIC18F2550 data sheet \cite{pic18f2550} detailed the required register writes to set up CCP2 as a PWM pin. First, the PWM period was written to the PR2 register (Timer2 period register). The PWM period is given by the equation:

\begin{equation}
\text{PWM Period} = [\text{PR2}+1] \times 4 \times T_\text{osc} \times (\text{TMR2 Prescale})
\end{equation}

where $T_\text{osc}$ is the oscillator period, so for a \SI{8}{\mega\hertz} clock speed $T_\text{osc}=\SI{125}{\nano\second}$. The factor of 4 is because each PIC operation takes four clock cycles to be executed, so the effective clock speed is $f_\text{osc}/4$. For a TMR2 prescaler setting of x1, the required PR2 value was 19 for a \SI{100}{\kilo\hertz} PWM signal. Every clock cycle, the Timer2 module increments the TMR2 register. TMR2 is then compared to the PR2 register, and if the two are equal then the TMR2 is reset to 0 on the next clock cycle \cite{pic18f2550}. This is how the \SI{100}{\kilo\hertz} interval is generated. The duty cycle was then defined by the equation:\\

\begin{equation}
\text{PWM Duty Cycle} = (\text{CCPR2L:CCP2CON\textless5:4\textgreater}) \times T_\text{osc} \times (\text{TMR2 Prescale Value}) \label{eq: duty cycle}
\end{equation}

Where CCPR2L is the CCP2 register low byte and CCP2CON\textless5:4\textgreater are bits 5 and 4 of the CCP2 control register which define the lower two bits of the duty cycle period. Equation \ref{eq: duty cycle} $(\text{CCPR2L:CCP2CON\textless5:4\textgreater}) = \num{4e6}$, so 0x0A was written to CCPR2L and 00 was written to CCP2CON\textless5:4\textgreater. After this was done, TRISB.3 was cleared to set the pin to a digital output. The TMR2 prescaler was set to x1 and Timer2 was enabled by writing 0x04 to T2CON (Timer2 control register). Finally, CCP2CON\textless3:2\textgreater was set to 11, to set CCP2 to PWM mode. This generated a stable \SI{100}{\kilo\hertz} square wave.\\